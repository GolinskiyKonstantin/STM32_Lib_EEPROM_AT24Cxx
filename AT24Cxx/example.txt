/*	сохраняем данный файл в кодировке UTF-8		*/

	author: Golinskiy Konstantin	e-mail: golinskiy.konstantin@gmail.com

/*
	AT24Cxx память равна хх килобит данных ( тоесть хх / 8 получаем килобайта )
	
	Модели бывают следущие:
	
	( частота шины I2C зависит от напряжения питания 100 kHz (1.8V, 2.5V, 2.7V) and 400 kHz (5V )-----------------------
	AT24C01   128 	 слов по 8 бит 	(1 килобит)		16 страниц, каждая емкостью по 8 байт		размер адреса памяти 7-bit
	AT24C02   256 	 слов по 8 бит 	(2 килобит)		32 страниц, каждая емкостью по 8 байт		размер адреса памяти 8-bit
	AT24C04   512 	 слов по 8 бит 	(4 килобит)		32 страниц, каждая емкостью по 16 байт		размер адреса памяти 9-bit
	AT24C08   1024 	 слов по 8 бит 	(8 килобит)		64 страниц, каждая емкостью по 16 байт		размер адреса памяти 10-bit
	AT24C16   2048 	 слов по 8 бит 	(16 килобит)	128 страниц, каждая емкостью по 16 байт		размер адреса памяти 11-bit
	
	( частота шины I2C зависит от напряжения питания 100 kHz (1.8V, 2.5V, 2.7V) and 400 kHz (5V )-----------------------
	AT24C32   4096 	 слов по 8 бит 	(32 килобит)	128 страниц, каждая емкостью по 32 байта	размер адреса памяти 12-bit
	AT24C64   8192 	 слов по 8 бит	(64 килобит)	256 страниц, каждая емкостью по 32 байта	размер адреса памяти 13-bit
	
	( частота шины I2C зависит от напряжения питания 1 MHz (5V), 400 kHz (2.7V, 2.5V) and 100 kHz (1.8V ) )-------------
	AT24C128  16,384 слов по 8 бит	(128 килобит)	256 страниц, каждая емкостью по 64 байта	размер адреса памяти 14-bit
	AT24C256  32,768 слов по 8 бит	(256 килобит)	512 страниц, каждая емкостью по 64 байта	размер адреса памяти 15-bit
	
	( частота шины I2C зависит от напряжения питания 1 MHz (5V), 400 kHz (2.7V, 2.5V) and 100 kHz (1.8V ) )-------------
	AT24C512  65,536 слов по 8 бит	(512 килобит)	512 страниц, каждая емкостью по 128 байта	размер адреса памяти 16-bit
	
	за 1 раз НЕЛЬЗЯ записать больше чем размер 1 страницы
	если записать больше чем размер 1 страницы то запишется страница до конца и все.
	
	Читать можно хоть всю память целиком за один раз.
	
	для указания адреса в памяти отправляем 1 или 2 байта взависимости от размера адреса памяти
	
	поддерживает запись одного байта так и страницы ( целиком или частично )
	
	задержка между записями (максимальной длительностью 5 мс).
	
	в стертом состоянии, вся память EEPROM заполнена единицами (все ячейки содержат значение слова данных 0xFF).
	
	A0 A1 A2 - данными ножками задаем адрес микросхемы 
				7-bit device address code - 1010  (A2)  (A1)  (A0). (A0 A1 A2  последние три бита )
				( если все три ножки притянуть к земле то получим 1010000 адрес (0x50 << 1) = 0xA0 )
				
	Vcc = от 1.7V до 5.5V
	
	SCL SDA  не забываем притянуть резисторами на 4.7 кОм к Питанию
	
	пин WP ( write protect ) - служит для блокировки записи
	( читать можно в любом случае )
	Когда вход защиты от записи подключен к Vcc, верхний квадрант памяти (1800-1FFFH) 
	защищен от операций записи. Для нормальной работы записи контакт защиты от записи 
	должен быть заземлен. Когда этот вывод остается неподключенным, 
	WP интерпретируется как ноль.
	Однако в таком случае возможна емкостная наводка помех на WP, поэтому Microchip 
	всегда рекомендует подключать этот вход к известному уровню. При использовании 
	для этой цели внешних верхних подтягивающих резисторов (pull-up) 
	их номинал должен быть 10 кОм или меньше.
	
*/



в файле #include "AT24Cxx.h" устанавливаем нужные настройки:

//########################  SETUP  ######################################################
		
		// указываем порт I2C -------------------------------------------------------------------
		#define AT24CXX_I2C 			hi2c2
		//---------------------------------------------------------------------------------------
		
		// Указываем адрес шины I2C -------------------------------------------------------------
		// A0 A1 A2 - данными ножками задаем адрес микросхемы 
		//		7-bit device address code - 1010  (A2)  (A1)  (A0). (A0 A1 A2  последние три бита )
		//		( если все три ножки притянуть к земле то получим 1010000 адрес (0x50 << 1) = 0xA0 )
		#define AT24CXX_I2C_ADDR		(0x50 << 1)    //A0 A1 A2 connect GND
		//---------------------------------------------------------------------------------------
		
		// Указываем тип памяти -----------------------------------------------------------------
		// нужное разкомментировать
		//#define AT24C01
		//#define AT24C02
		//#define AT24C04
		//#define AT24C08
		//#define AT24C16
		//#define AT24C32
		#define AT24C64
		//#define AT24C128
		//#define AT24C256
		//#define AT24C512
		//---------------------------------------------------------------------------------------
		
		//--  Cесли используем порт WP для блокировки памяти тогда раскомментировать ------------
		// если на порту VCC то память заблоктрована для записи, если GND то разблокирована ( можно записывать )
		// читать можно в любом случае		
		#define WP_PORT
		
		//----------------------------------------------------------------------------------------
		#ifdef WP_PORT
			#if defined (WP_GPIO_Port)
			#else
				#define WP_GPIO_Port    GPIOA
				#define WP_Pin			GPIO_PIN_14
			#endif
		#endif
		//---------------------------------------------------------------------------------------
		
		
//#######################################################################################

//////////////////////////////////////////////////////////////////////////////////////////////////
	
	#include "AT24Cxx.h"

	uint8_t mass_read[300];
	.........
	.........

main()=============================================================================================================================

	/////////////////////////////////////////////////////////////////////////////////

	HAL_Delay (100);

	AT24Cxx_erase_chip(); // отчищаем мамять ( чип )

	HAL_Delay (10);	// после отчистки ждем так как чип прожигается

	// создаем массив который будем сохранять в память
	char text_mass[] = "Hello World !!! QWERTY 1234567890 Arduino STM32F103C8T6 Golinskiy Konstantin Odessa";

	// записываем в память массив который создали выше ( по адресу 20 ) и функция вернет последний адрес конца записи ( может быть полезна )
	uint16_t offset_write = AT24Cxx_write( 20, (uint8_t*)text_mass, sizeof( text_mass));

	// считываем из памяти в массив который создали выше ( по адресу 20 ) и функция вернет последний адрес конца чтения ( может быть полезна )
	uint16_t offset_read = AT24Cxx_read( 20, (uint8_t*)mass_read, sizeof( text_mass));

			
	////////////////////////////////////////////////////////////////////////////////
	.........
	.........
	.........

while(1)===========================================================================================================================

	.........
	.........
	.........
	.........

=== end while(1) ==================================================================================================================
=== end main() ====================================================================================================================
